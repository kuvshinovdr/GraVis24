Какой вид представления графа лучше?

Удобно представить в виде списка смежности

Псевдокод

Для первой вершины в которую вошли помечаем все вершины из неё исходящие, как первый компонент связности, далее переходим в следующую вершину, по принципу dfs



int component[Макс. количество элементов]; //для номеров компонент

Определение функции dfs(v, num) {
    component[v] = num;
    Для каждой вершины u из графа:
        Если вершина u не присвоена к массиву component:
            dfs(u, num);
}

Осуществление основной цели
num2 = 0;
Для временной переменной v от 0 до n:
    Если в массиве component нет вершины v:
        dfs(v, ++num2);

Оценка сложности алгоритма и времени

Время должно представлять из себя О(m+n), где числа это число рёбер и число вершин, время таково, так как каждую вершину мы посещаем лишь раз и в вершине помечаем из неё исходящие, принадлежащие ей лишь раз.

Какой метод визуализации лучше?

Представить граф визуально в качестве обычного графа, в качестве пометки, что вершина принадлежит компоненте связности в соответствии с количеством компонент, которому она принадлежит, окрашивать её в соответствии со значением (цвета присвоить вершинам и изменять попутно алгоритму(по типу пирог цветов)). 
Конечный результат будет наглядно представлять то же самое, что и граф с помеченным количеством подсоединенных ребер к вершинам, по которым из неё можно выйти (количество рёбер, принадлежащих вершине).

Визуализация - 2D
Вершины-ребра
Цвета вершин
Текстовые метки в виде соответствия цветов цифрам
Дополнительные данные: допустим стек с весом вершин
Замена цвета ребра в соответствии с обновляемым значением

(Укажите, нужно ли оформить более официально?)
